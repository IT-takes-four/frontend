/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Your API
 * Development documentation
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "../custom-axios";
export type BadRequestErrorResponseError =
  (typeof BadRequestErrorResponseError)[keyof typeof BadRequestErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BadRequestErrorResponseError = {
  Bad_request: "Bad request",
} as const;

/**
 * 400 Bad request
 */
export interface BadRequestErrorResponse {
  error: BadRequestErrorResponseError;
}

export type UnauthorizedErrorResponseError =
  (typeof UnauthorizedErrorResponseError)[keyof typeof UnauthorizedErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UnauthorizedErrorResponseError = {
  Unauthorized: "Unauthorized",
} as const;

export type UnauthorizedErrorResponseMessage =
  (typeof UnauthorizedErrorResponseMessage)[keyof typeof UnauthorizedErrorResponseMessage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UnauthorizedErrorResponseMessage = {
  Authentication_required: "Authentication required",
} as const;

/**
 * 401 Unauthorized
 */
export interface UnauthorizedErrorResponse {
  error: UnauthorizedErrorResponseError;
  message: UnauthorizedErrorResponseMessage;
}

export type ForbiddenErrorResponseError =
  (typeof ForbiddenErrorResponseError)[keyof typeof ForbiddenErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenErrorResponseError = {
  Forbidden: "Forbidden",
} as const;

/**
 * 403 Forbidden
 */
export interface ForbiddenErrorResponse {
  error: ForbiddenErrorResponseError;
}

export type NotFoundErrorResponseError =
  (typeof NotFoundErrorResponseError)[keyof typeof NotFoundErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotFoundErrorResponseError = {
  Not_found: "Not found",
} as const;

/**
 * 404 Not found
 */
export interface NotFoundErrorResponse {
  error: NotFoundErrorResponseError;
}

export type ConflictErrorResponseError =
  (typeof ConflictErrorResponseError)[keyof typeof ConflictErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConflictErrorResponseError = {
  Conflict: "Conflict",
} as const;

/**
 * 409 Conflict
 */
export interface ConflictErrorResponse {
  error: ConflictErrorResponseError;
}

export type InternalServerErrorResponseError =
  (typeof InternalServerErrorResponseError)[keyof typeof InternalServerErrorResponseError];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InternalServerErrorResponseError = {
  Internal_server_error: "Internal server error",
} as const;

/**
 * 500 Internal server error
 */
export interface InternalServerErrorResponse {
  error: InternalServerErrorResponseError;
}

export type BaseMessageRole =
  (typeof BaseMessageRole)[keyof typeof BaseMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BaseMessageRole = {
  user: "user",
  assistant: "assistant",
  system: "system",
} as const;

export interface BaseMessage {
  role: BaseMessageRole;
  /** @nullable */
  content: string | null;
}

export type ChatRole = (typeof ChatRole)[keyof typeof ChatRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChatRole = {
  user: "user",
  assistant: "assistant",
  system: "system",
  function: "function",
} as const;

export type DeleteSuccessResponseMessage =
  (typeof DeleteSuccessResponseMessage)[keyof typeof DeleteSuccessResponseMessage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteSuccessResponseMessage = {
  Removed_successfully: "Removed successfully",
} as const;

export type DeleteSuccessResponseId = string | number;

export interface DeleteSuccessResponse {
  message: DeleteSuccessResponseMessage;
  id: DeleteSuccessResponseId;
}

export type FunctionMessageRole =
  (typeof FunctionMessageRole)[keyof typeof FunctionMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionMessageRole = {
  function: "function",
} as const;

export interface FunctionMessage {
  role: FunctionMessageRole;
  name: string;
  /** @nullable */
  content: string | null;
}

export type GameCoverId = string | number;

export type GameCoverWidth = string | number;

export type GameCoverHeight = string | number;

export interface GameCover {
  id: GameCoverId;
  /** @nullable */
  url: string | null;
  width?: GameCoverWidth;
  height?: GameCoverHeight;
}

export type GameGenreId = string | number;

export interface GameGenre {
  id: GameGenreId;
  name: string;
  slug: string;
}

export interface GameListResponse {
  results: Game[];
  meta: Meta;
}

export interface GamePlatform {
  id: number;
  name: string;
  slug: string;
}

export interface Game {
  id: number;
  name: string;
  slug: string;
  /** @nullable */
  summary?: string | null;
  /** @nullable */
  storyline?: string | null;
  firstReleaseDate?: number;
  createdAt?: number;
  totalRating?: number;
  /** @nullable */
  involvedCompanies?: string | null;
  /** @nullable */
  keywords?: string | null;
  updatedAt?: number;
  isPopular?: boolean;
  cover: GameCover;
  screenshots: GameScreenshot[];
  websites: GameWebsite[];
  platforms: GamePlatform[];
  genres: GameGenre[];
  types: GameType[];
  similarGames: GameSimilarGame[];
}

export interface GameScreenshot {
  id: number;
  /** @nullable */
  url: string | null;
  width?: number;
  height?: number;
}

export interface GameSimilarGame {
  id: number;
}

export interface GameType {
  id: number;
  type: string;
}

export interface GameWebsite {
  id: number;
  url: string;
  trusted?: boolean;
  typeId?: number;
}

export type Message = BaseMessage | FunctionMessage;

export interface Meta {
  total: number;
  limit: number;
  offset: number;
}

export interface OpenAIChatRequest {
  messages: Message[];
  showOnlyGames?: boolean;
}

export type OpenAIChatResponseMessageRole =
  (typeof OpenAIChatResponseMessageRole)[keyof typeof OpenAIChatResponseMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIChatResponseMessageRole = {
  assistant: "assistant",
} as const;

export type OpenAIChatResponseMessage = {
  role: OpenAIChatResponseMessageRole;
  content: string;
  gameData: Game;
  gameResults?: Game[];
  userRating?: number;
  /** @nullable */
  userStatus?: string | null;
  /** @nullable */
  userReview?: string | null;
};

export interface OpenAIChatResponse {
  message: OpenAIChatResponseMessage;
}

export type StatusEnum = (typeof StatusEnum)[keyof typeof StatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusEnum = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type UserGameDataSource =
  (typeof UserGameDataSource)[keyof typeof UserGameDataSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGameDataSource = {
  steam: "steam",
  gog: "gog",
  manual: "manual",
} as const;

export interface UserGameData {
  status: StatusEnum;
  /** @nullable */
  rating: string | null;
  /** @nullable */
  review?: string | null;
  /**
   * @nullable
   * @pattern ^\d+$
   */
  platformId: string | null;
  /** @nullable */
  addedAt: string | null;
  source?: UserGameDataSource;
}

export type UserGamePatchResponseMessage =
  (typeof UserGamePatchResponseMessage)[keyof typeof UserGamePatchResponseMessage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGamePatchResponseMessage = {
  Game_updated_successfully: "Game updated successfully",
} as const;

export type UserGamePatchResponseGameUserId = string | number;

export type UserGamePatchResponseGameGameId = string | number;

export type UserGamePatchResponseGame = {
  userId: UserGamePatchResponseGameUserId;
  gameId: UserGamePatchResponseGameGameId;
  status: string;
  /** @nullable */
  rating: string | null;
  /** @nullable */
  review: string | null;
  /**
   * @nullable
   * @pattern ^\d+$
   */
  platformId: string | null;
  source: string;
  /** @nullable */
  addedAt: string | null;
};

export interface UserGamePatchResponse {
  message: UserGamePatchResponseMessage;
  game: UserGamePatchResponseGame;
}

export type UserGamePostGameId = string | number;

export type UserGamePostRating = string | number;

export type UserGamePostPlatformId = string | number;

export interface UserGamePost {
  gameId: UserGamePostGameId;
  status: StatusEnum;
  rating: UserGamePostRating;
  /** @nullable */
  review?: string | null;
  platformId: UserGamePostPlatformId;
}

export type UserGameResponseMetaTotal = string | number;

export type UserGameResponseMeta = {
  total: UserGameResponseMetaTotal;
};

export interface UserGameResponse {
  games: UserGameWithUserData[];
  meta: UserGameResponseMeta;
}

export type UserGameWithUserDataAllOf = {
  userGameData: UserGameData;
};

export type UserGameWithUserData = Game & UserGameWithUserDataAllOf;

export type UserResponseId = string | number;

export type UserResponseGamesItem = { [key: string]: unknown };

export interface UserResponse {
  id: UserResponseId;
  image: string;
  name: string;
  username: string;
  games: UserResponseGamesItem[];
}

export type GetApiGamesParams = {
  limit?: string | number;
  offset?: string | number;
  platformId?: string | number;
};

export type GetApiGamesSearchParams = {
  q: string;
  limit?: string | number;
  offset?: string | number;
  fresh?: string;
};

export type PostApiUserByUsernameGamesBodyOneGameId = string | number;

export type PostApiUserByUsernameGamesBodyOneStatus =
  (typeof PostApiUserByUsernameGamesBodyOneStatus)[keyof typeof PostApiUserByUsernameGamesBodyOneStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiUserByUsernameGamesBodyOneStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PostApiUserByUsernameGamesBodyOneRating = string | number;

export type PostApiUserByUsernameGamesBodyOnePlatformId = string | number;

export type PostApiUserByUsernameGamesBodyOne = {
  gameId: PostApiUserByUsernameGamesBodyOneGameId;
  status: PostApiUserByUsernameGamesBodyOneStatus;
  rating: PostApiUserByUsernameGamesBodyOneRating;
  review?: string;
  platformId: PostApiUserByUsernameGamesBodyOnePlatformId;
};

export type PostApiUserByUsernameGamesBodyTwoGameId = string | number;

export type PostApiUserByUsernameGamesBodyTwoStatus =
  (typeof PostApiUserByUsernameGamesBodyTwoStatus)[keyof typeof PostApiUserByUsernameGamesBodyTwoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiUserByUsernameGamesBodyTwoStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PostApiUserByUsernameGamesBodyTwoRating = string | number;

export type PostApiUserByUsernameGamesBodyTwoPlatformId = string | number;

export type PostApiUserByUsernameGamesBodyTwo = {
  gameId: PostApiUserByUsernameGamesBodyTwoGameId;
  status: PostApiUserByUsernameGamesBodyTwoStatus;
  rating: PostApiUserByUsernameGamesBodyTwoRating;
  review?: string;
  platformId: PostApiUserByUsernameGamesBodyTwoPlatformId;
};

export type PostApiUserByUsernameGamesBodyThreeGameId = string | number;

export type PostApiUserByUsernameGamesBodyThreeStatus =
  (typeof PostApiUserByUsernameGamesBodyThreeStatus)[keyof typeof PostApiUserByUsernameGamesBodyThreeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiUserByUsernameGamesBodyThreeStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PostApiUserByUsernameGamesBodyThreeRating = string | number;

export type PostApiUserByUsernameGamesBodyThreePlatformId = string | number;

export type PostApiUserByUsernameGamesBodyThree = {
  gameId: PostApiUserByUsernameGamesBodyThreeGameId;
  status: PostApiUserByUsernameGamesBodyThreeStatus;
  rating: PostApiUserByUsernameGamesBodyThreeRating;
  review?: string;
  platformId: PostApiUserByUsernameGamesBodyThreePlatformId;
};

export type PatchApiUserByUsernameGamesByIdBodyOneStatus =
  (typeof PatchApiUserByUsernameGamesByIdBodyOneStatus)[keyof typeof PatchApiUserByUsernameGamesByIdBodyOneStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatchApiUserByUsernameGamesByIdBodyOneStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PatchApiUserByUsernameGamesByIdBodyOnePlatformId = string | number;

export type PatchApiUserByUsernameGamesByIdBodyOne = {
  status?: PatchApiUserByUsernameGamesByIdBodyOneStatus;
  rating?: number;
  review?: string;
  platformId?: PatchApiUserByUsernameGamesByIdBodyOnePlatformId;
};

export type PatchApiUserByUsernameGamesByIdBodyTwoStatus =
  (typeof PatchApiUserByUsernameGamesByIdBodyTwoStatus)[keyof typeof PatchApiUserByUsernameGamesByIdBodyTwoStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatchApiUserByUsernameGamesByIdBodyTwoStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PatchApiUserByUsernameGamesByIdBodyTwoPlatformId = string | number;

export type PatchApiUserByUsernameGamesByIdBodyTwo = {
  status?: PatchApiUserByUsernameGamesByIdBodyTwoStatus;
  rating?: number;
  review?: string;
  platformId?: PatchApiUserByUsernameGamesByIdBodyTwoPlatformId;
};

export type PatchApiUserByUsernameGamesByIdBodyThreeStatus =
  (typeof PatchApiUserByUsernameGamesByIdBodyThreeStatus)[keyof typeof PatchApiUserByUsernameGamesByIdBodyThreeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PatchApiUserByUsernameGamesByIdBodyThreeStatus = {
  finished: "finished",
  playing: "playing",
  dropped: "dropped",
  online: "online",
  want_to_play: "want_to_play",
  backlog: "backlog",
} as const;

export type PatchApiUserByUsernameGamesByIdBodyThreePlatformId =
  | string
  | number;

export type PatchApiUserByUsernameGamesByIdBodyThree = {
  status?: PatchApiUserByUsernameGamesByIdBodyThreeStatus;
  rating?: number;
  review?: string;
  platformId?: PatchApiUserByUsernameGamesByIdBodyThreePlatformId;
};

export type PostApiChatAiBodyOneMessagesItemRole =
  (typeof PostApiChatAiBodyOneMessagesItemRole)[keyof typeof PostApiChatAiBodyOneMessagesItemRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiChatAiBodyOneMessagesItemRole = {
  system: "system",
  user: "user",
  assistant: "assistant",
  tool: "tool",
} as const;

export type PostApiChatAiBodyOneMessagesItem = {
  role: PostApiChatAiBodyOneMessagesItemRole;
  /** @nullable */
  content: string | null;
  name?: string;
};

export type PostApiChatAiBodyOne = {
  messages: PostApiChatAiBodyOneMessagesItem[];
};

export type PostApiChatAiBodyTwoMessagesItemRole =
  (typeof PostApiChatAiBodyTwoMessagesItemRole)[keyof typeof PostApiChatAiBodyTwoMessagesItemRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiChatAiBodyTwoMessagesItemRole = {
  system: "system",
  user: "user",
  assistant: "assistant",
  tool: "tool",
} as const;

export type PostApiChatAiBodyTwoMessagesItem = {
  role: PostApiChatAiBodyTwoMessagesItemRole;
  /** @nullable */
  content: string | null;
  name?: string;
};

export type PostApiChatAiBodyTwo = {
  messages: PostApiChatAiBodyTwoMessagesItem[];
};

export type PostApiChatAiBodyThreeMessagesItemRole =
  (typeof PostApiChatAiBodyThreeMessagesItemRole)[keyof typeof PostApiChatAiBodyThreeMessagesItemRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostApiChatAiBodyThreeMessagesItemRole = {
  system: "system",
  user: "user",
  assistant: "assistant",
  tool: "tool",
} as const;

export type PostApiChatAiBodyThreeMessagesItem = {
  role: PostApiChatAiBodyThreeMessagesItemRole;
  /** @nullable */
  content: string | null;
  name?: string;
};

export type PostApiChatAiBodyThree = {
  messages: PostApiChatAiBodyThreeMessagesItem[];
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns info about the currently authenticated user
 * @summary Get current authenticated user
 */
export const getApiMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserResponse>(
    { url: `http://localhost:3030/api/me`, method: "GET", signal },
    options,
  );
};

export const getGetApiMeQueryKey = () => {
  return [`http://localhost:3030/api/me`] as const;
};

export const getGetApiMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiMe>>,
  TError = UnauthorizedErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetApiMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiMe>>> = ({
    signal,
  }) => getApiMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiMe>>
>;
export type GetApiMeQueryError = UnauthorizedErrorResponse;

export function useGetApiMe<
  TData = Awaited<ReturnType<typeof getApiMe>>,
  TError = UnauthorizedErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiMe>>,
          TError,
          Awaited<ReturnType<typeof getApiMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiMe<
  TData = Awaited<ReturnType<typeof getApiMe>>,
  TError = UnauthorizedErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiMe>>,
          TError,
          Awaited<ReturnType<typeof getApiMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiMe<
  TData = Awaited<ReturnType<typeof getApiMe>>,
  TError = UnauthorizedErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get current authenticated user
 */

export function useGetApiMe<
  TData = Awaited<ReturnType<typeof getApiMe>>,
  TError = UnauthorizedErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns public info about a user, by their username
 * @summary Get a user by username
 */
export const getApiUserByUsername = (
  username: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserResponse>(
    {
      url: `http://localhost:3030/api/user/${username}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetApiUserByUsernameQueryKey = (username: string) => {
  return [`http://localhost:3030/api/user/${username}`] as const;
};

export const getGetApiUserByUsernameQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiUserByUsername>>,
  TError = NotFoundErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsername>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApiUserByUsernameQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiUserByUsername>>
  > = ({ signal }) => getApiUserByUsername(username, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiUserByUsername>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiUserByUsernameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiUserByUsername>>
>;
export type GetApiUserByUsernameQueryError = NotFoundErrorResponse;

export function useGetApiUserByUsername<
  TData = Awaited<ReturnType<typeof getApiUserByUsername>>,
  TError = NotFoundErrorResponse,
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsername>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUserByUsername>>,
          TError,
          Awaited<ReturnType<typeof getApiUserByUsername>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiUserByUsername<
  TData = Awaited<ReturnType<typeof getApiUserByUsername>>,
  TError = NotFoundErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsername>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUserByUsername>>,
          TError,
          Awaited<ReturnType<typeof getApiUserByUsername>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiUserByUsername<
  TData = Awaited<ReturnType<typeof getApiUserByUsername>>,
  TError = NotFoundErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsername>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a user by username
 */

export function useGetApiUserByUsername<
  TData = Awaited<ReturnType<typeof getApiUserByUsername>>,
  TError = NotFoundErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsername>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiUserByUsernameQueryOptions(username, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of games from the catalog. Supports filtering by platform and pagination.

 * @summary Get all games
 */
export const getApiGames = (
  params?: GetApiGamesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GameListResponse>(
    { url: `http://localhost:3030/api/games`, method: "GET", params, signal },
    options,
  );
};

export const getGetApiGamesQueryKey = (params?: GetApiGamesParams) => {
  return [
    `http://localhost:3030/api/games`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApiGamesQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiGames>>,
  TError = InternalServerErrorResponse,
>(
  params?: GetApiGamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiGames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetApiGamesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiGames>>> = ({
    signal,
  }) => getApiGames(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiGames>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiGamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiGames>>
>;
export type GetApiGamesQueryError = InternalServerErrorResponse;

export function useGetApiGames<
  TData = Awaited<ReturnType<typeof getApiGames>>,
  TError = InternalServerErrorResponse,
>(
  params: undefined | GetApiGamesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiGames>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGames>>,
          TError,
          Awaited<ReturnType<typeof getApiGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiGames<
  TData = Awaited<ReturnType<typeof getApiGames>>,
  TError = InternalServerErrorResponse,
>(
  params?: GetApiGamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiGames>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGames>>,
          TError,
          Awaited<ReturnType<typeof getApiGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiGames<
  TData = Awaited<ReturnType<typeof getApiGames>>,
  TError = InternalServerErrorResponse,
>(
  params?: GetApiGamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiGames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all games
 */

export function useGetApiGames<
  TData = Awaited<ReturnType<typeof getApiGames>>,
  TError = InternalServerErrorResponse,
>(
  params?: GetApiGamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getApiGames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiGamesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Performs full-text search against local DB and IGDB fallback. Uses caching and queues.

 * @summary Search games by name
 */
export const getApiGamesSearch = (
  params: GetApiGamesSearchParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GameListResponse>(
    {
      url: `http://localhost:3030/api/games/search`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetApiGamesSearchQueryKey = (
  params: GetApiGamesSearchParams,
) => {
  return [
    `http://localhost:3030/api/games/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApiGamesSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiGamesSearch>>,
  TError = BadRequestErrorResponse | InternalServerErrorResponse,
>(
  params: GetApiGamesSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiGamesSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApiGamesSearchQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiGamesSearch>>
  > = ({ signal }) => getApiGamesSearch(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiGamesSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiGamesSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiGamesSearch>>
>;
export type GetApiGamesSearchQueryError =
  | BadRequestErrorResponse
  | InternalServerErrorResponse;

export function useGetApiGamesSearch<
  TData = Awaited<ReturnType<typeof getApiGamesSearch>>,
  TError = BadRequestErrorResponse | InternalServerErrorResponse,
>(
  params: GetApiGamesSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiGamesSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGamesSearch>>,
          TError,
          Awaited<ReturnType<typeof getApiGamesSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiGamesSearch<
  TData = Awaited<ReturnType<typeof getApiGamesSearch>>,
  TError = BadRequestErrorResponse | InternalServerErrorResponse,
>(
  params: GetApiGamesSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiGamesSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGamesSearch>>,
          TError,
          Awaited<ReturnType<typeof getApiGamesSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiGamesSearch<
  TData = Awaited<ReturnType<typeof getApiGamesSearch>>,
  TError = BadRequestErrorResponse | InternalServerErrorResponse,
>(
  params: GetApiGamesSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiGamesSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search games by name
 */

export function useGetApiGamesSearch<
  TData = Awaited<ReturnType<typeof getApiGamesSearch>>,
  TError = BadRequestErrorResponse | InternalServerErrorResponse,
>(
  params: GetApiGamesSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiGamesSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiGamesSearchQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all games in a user's library with their statuses, ratings, and reviews

 * @summary Get all games for a user by username
 */
export const getApiUserByUsernameGames = (
  username: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserGameResponse>(
    {
      url: `http://localhost:3030/api/user/${username}/games`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetApiUserByUsernameGamesQueryKey = (username: string) => {
  return [`http://localhost:3030/api/user/${username}/games`] as const;
};

export const getGetApiUserByUsernameGamesQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApiUserByUsernameGamesQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiUserByUsernameGames>>
  > = ({ signal }) =>
    getApiUserByUsernameGames(username, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApiUserByUsernameGamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiUserByUsernameGames>>
>;
export type GetApiUserByUsernameGamesQueryError =
  | NotFoundErrorResponse
  | InternalServerErrorResponse;

export function useGetApiUserByUsernameGames<
  TData = Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
          TError,
          Awaited<ReturnType<typeof getApiUserByUsernameGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiUserByUsernameGames<
  TData = Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
          TError,
          Awaited<ReturnType<typeof getApiUserByUsernameGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApiUserByUsernameGames<
  TData = Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all games for a user by username
 */

export function useGetApiUserByUsernameGames<
  TData = Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiUserByUsernameGames>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiUserByUsernameGamesQueryOptions(
    username,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Adds a game to the authenticated user's library. Username must match the authorized user.

 * @summary Add a game to user's library
 */
export const postApiUserByUsernameGames = (
  username: string,
  postApiUserByUsernameGamesBody:
    | PostApiUserByUsernameGamesBodyOne
    | PostApiUserByUsernameGamesBodyTwo
    | PostApiUserByUsernameGamesBodyThree,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserGamePost>(
    {
      url: `http://localhost:3030/api/user/${username}/games`,
      method: "POST",
      data: postApiUserByUsernameGamesBody,
      signal,
    },
    options,
  );
};

export const getPostApiUserByUsernameGamesMutationOptions = <
  TError =
    | BadRequestErrorResponse
    | ForbiddenErrorResponse
    | ConflictErrorResponse
    | InternalServerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiUserByUsernameGames>>,
    TError,
    {
      username: string;
      data:
        | PostApiUserByUsernameGamesBodyOne
        | PostApiUserByUsernameGamesBodyTwo
        | PostApiUserByUsernameGamesBodyThree;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiUserByUsernameGames>>,
  TError,
  {
    username: string;
    data:
      | PostApiUserByUsernameGamesBodyOne
      | PostApiUserByUsernameGamesBodyTwo
      | PostApiUserByUsernameGamesBodyThree;
  },
  TContext
> => {
  const mutationKey = ["postApiUserByUsernameGames"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiUserByUsernameGames>>,
    {
      username: string;
      data:
        | PostApiUserByUsernameGamesBodyOne
        | PostApiUserByUsernameGamesBodyTwo
        | PostApiUserByUsernameGamesBodyThree;
    }
  > = (props) => {
    const { username, data } = props ?? {};

    return postApiUserByUsernameGames(username, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiUserByUsernameGamesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiUserByUsernameGames>>
>;
export type PostApiUserByUsernameGamesMutationBody =
  | PostApiUserByUsernameGamesBodyOne
  | PostApiUserByUsernameGamesBodyTwo
  | PostApiUserByUsernameGamesBodyThree;
export type PostApiUserByUsernameGamesMutationError =
  | BadRequestErrorResponse
  | ForbiddenErrorResponse
  | ConflictErrorResponse
  | InternalServerErrorResponse;

/**
 * @summary Add a game to user's library
 */
export const usePostApiUserByUsernameGames = <
  TError =
    | BadRequestErrorResponse
    | ForbiddenErrorResponse
    | ConflictErrorResponse
    | InternalServerErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiUserByUsernameGames>>,
      TError,
      {
        username: string;
        data:
          | PostApiUserByUsernameGamesBodyOne
          | PostApiUserByUsernameGamesBodyTwo
          | PostApiUserByUsernameGamesBodyThree;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postApiUserByUsernameGames>>,
  TError,
  {
    username: string;
    data:
      | PostApiUserByUsernameGamesBodyOne
      | PostApiUserByUsernameGamesBodyTwo
      | PostApiUserByUsernameGamesBodyThree;
  },
  TContext
> => {
  const mutationOptions = getPostApiUserByUsernameGamesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates game status, rating, review or platform in the authenticated user's library. At least one field must be provided.
 * @summary Update a game in user's library
 */
export const patchApiUserByUsernameGamesById = (
  username: string,
  id: string | number,
  patchApiUserByUsernameGamesByIdBody:
    | PatchApiUserByUsernameGamesByIdBodyOne
    | PatchApiUserByUsernameGamesByIdBodyTwo
    | PatchApiUserByUsernameGamesByIdBodyThree,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UserGamePatchResponse>(
    {
      url: `http://localhost:3030/api/user/${username}/games/${id}`,
      method: "PATCH",
      data: patchApiUserByUsernameGamesByIdBody,
    },
    options,
  );
};

export const getPatchApiUserByUsernameGamesByIdMutationOptions = <
  TError =
    | BadRequestErrorResponse
    | ForbiddenErrorResponse
    | NotFoundErrorResponse
    | InternalServerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>,
    TError,
    {
      username: string;
      id: string | number;
      data:
        | PatchApiUserByUsernameGamesByIdBodyOne
        | PatchApiUserByUsernameGamesByIdBodyTwo
        | PatchApiUserByUsernameGamesByIdBodyThree;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>,
  TError,
  {
    username: string;
    id: string | number;
    data:
      | PatchApiUserByUsernameGamesByIdBodyOne
      | PatchApiUserByUsernameGamesByIdBodyTwo
      | PatchApiUserByUsernameGamesByIdBodyThree;
  },
  TContext
> => {
  const mutationKey = ["patchApiUserByUsernameGamesById"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>,
    {
      username: string;
      id: string | number;
      data:
        | PatchApiUserByUsernameGamesByIdBodyOne
        | PatchApiUserByUsernameGamesByIdBodyTwo
        | PatchApiUserByUsernameGamesByIdBodyThree;
    }
  > = (props) => {
    const { username, id, data } = props ?? {};

    return patchApiUserByUsernameGamesById(username, id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchApiUserByUsernameGamesByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>
>;
export type PatchApiUserByUsernameGamesByIdMutationBody =
  | PatchApiUserByUsernameGamesByIdBodyOne
  | PatchApiUserByUsernameGamesByIdBodyTwo
  | PatchApiUserByUsernameGamesByIdBodyThree;
export type PatchApiUserByUsernameGamesByIdMutationError =
  | BadRequestErrorResponse
  | ForbiddenErrorResponse
  | NotFoundErrorResponse
  | InternalServerErrorResponse;

/**
 * @summary Update a game in user's library
 */
export const usePatchApiUserByUsernameGamesById = <
  TError =
    | BadRequestErrorResponse
    | ForbiddenErrorResponse
    | NotFoundErrorResponse
    | InternalServerErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>,
      TError,
      {
        username: string;
        id: string | number;
        data:
          | PatchApiUserByUsernameGamesByIdBodyOne
          | PatchApiUserByUsernameGamesByIdBodyTwo
          | PatchApiUserByUsernameGamesByIdBodyThree;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchApiUserByUsernameGamesById>>,
  TError,
  {
    username: string;
    id: string | number;
    data:
      | PatchApiUserByUsernameGamesByIdBodyOne
      | PatchApiUserByUsernameGamesByIdBodyTwo
      | PatchApiUserByUsernameGamesByIdBodyThree;
  },
  TContext
> => {
  const mutationOptions =
    getPatchApiUserByUsernameGamesByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes a game from the authenticated user's library by game ID.
 * @summary Remove a game from user's library
 */
export const deleteApiUserByUsernameGamesById = (
  username: string,
  id: string | number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UserGamePatchResponse>(
    {
      url: `http://localhost:3030/api/user/${username}/games/${id}`,
      method: "DELETE",
    },
    options,
  );
};

export const getDeleteApiUserByUsernameGamesByIdMutationOptions = <
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>,
    TError,
    { username: string; id: string | number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>,
  TError,
  { username: string; id: string | number },
  TContext
> => {
  const mutationKey = ["deleteApiUserByUsernameGamesById"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>,
    { username: string; id: string | number }
  > = (props) => {
    const { username, id } = props ?? {};

    return deleteApiUserByUsernameGamesById(username, id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteApiUserByUsernameGamesByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>
>;

export type DeleteApiUserByUsernameGamesByIdMutationError =
  | NotFoundErrorResponse
  | InternalServerErrorResponse;

/**
 * @summary Remove a game from user's library
 */
export const useDeleteApiUserByUsernameGamesById = <
  TError = NotFoundErrorResponse | InternalServerErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>,
      TError,
      { username: string; id: string | number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteApiUserByUsernameGamesById>>,
  TError,
  { username: string; id: string | number },
  TContext
> => {
  const mutationOptions =
    getDeleteApiUserByUsernameGamesByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Uses OpenAI + function calling via ai-sdk
 * @summary Stream AI chat with game assistant
 */
export const postApiChatAi = (
  postApiChatAiBody:
    | PostApiChatAiBodyOne
    | PostApiChatAiBodyTwo
    | PostApiChatAiBodyThree,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `http://localhost:3030/api/chat/ai`,
      method: "POST",
      data: postApiChatAiBody,
      signal,
    },
    options,
  );
};

export const getPostApiChatAiMutationOptions = <
  TError = UnauthorizedErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiChatAi>>,
    TError,
    {
      data:
        | PostApiChatAiBodyOne
        | PostApiChatAiBodyTwo
        | PostApiChatAiBodyThree;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiChatAi>>,
  TError,
  {
    data: PostApiChatAiBodyOne | PostApiChatAiBodyTwo | PostApiChatAiBodyThree;
  },
  TContext
> => {
  const mutationKey = ["postApiChatAi"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiChatAi>>,
    {
      data:
        | PostApiChatAiBodyOne
        | PostApiChatAiBodyTwo
        | PostApiChatAiBodyThree;
    }
  > = (props) => {
    const { data } = props ?? {};

    return postApiChatAi(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiChatAiMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiChatAi>>
>;
export type PostApiChatAiMutationBody =
  | PostApiChatAiBodyOne
  | PostApiChatAiBodyTwo
  | PostApiChatAiBodyThree;
export type PostApiChatAiMutationError = UnauthorizedErrorResponse;

/**
 * @summary Stream AI chat with game assistant
 */
export const usePostApiChatAi = <
  TError = UnauthorizedErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiChatAi>>,
      TError,
      {
        data:
          | PostApiChatAiBodyOne
          | PostApiChatAiBodyTwo
          | PostApiChatAiBodyThree;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postApiChatAi>>,
  TError,
  {
    data: PostApiChatAiBodyOne | PostApiChatAiBodyTwo | PostApiChatAiBodyThree;
  },
  TContext
> => {
  const mutationOptions = getPostApiChatAiMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
